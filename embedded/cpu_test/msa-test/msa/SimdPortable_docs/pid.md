PID调节经验总结
=============

PID控制器参数选择的方法很多，例如试凑法、临界比例度法、扩充临界比例度法等。
但是，对于PID控制而言，参数的选择始终是一件非常烦杂的工作，需要经过不断的
调整才能得到较为满意的控制效果。依据经验，一般PID参数确定的步骤如下:

	1. 确定比例系数Kp
	   确定比例系数Kp时，首先去掉PID的积分项和微分项，可以令Ti=0、Td=0，
	   使之成为 纯比例调节。输入设定为系统允许输出最大值的60％～70％，
	   比例系数Kp由0开始逐渐增大，直至系统出现振荡；
	   再反过来，从此时的比例系数Kp逐渐减小，直至系统振荡消失。记录此时的比例系数Kp，
	   设定PID的比例系数Kp为当前值的60％～70％。
	2.  确定积分时间常数Ti
	   比例系数Kp确定之后，设定一个较大的积分时间常数Ti，然后逐渐减小Ti，
	   直至系统出现振荡，然后再反过来，逐渐增大Ti，直至系统振荡消失。
	   记录此时的Ti，设定PID的积分时间常数Ti为当前值的150％～180％。
	3.  确定微分时间常数Td
	   微分时间常数Td一般不用设定，为0即可，此时PID调节转换为PI调节。
	   如果需要设定，则与确定Kp的方法相同，取不振荡时其值的30％。
	4.  系统空载、带载联调
		对PID参数进行微调，直到满足性能要求

PID 算法
=======


$$ P = e(t) $$

$$ I = \int_{0}^{t} e(t) \,dt $$

$$ D = \frac{de(t)}{dt} $$

$$ u(t) = k_p \(P + \frac{1}{T_i} I + T_d D \) $$

其中$K_p$为比例系数，$T_i$为积分时间常量，$T_d$为微分时间常量



P 比例控制
---------
首先是比例控制。比例控制就好比是通过水桶往水缸加水或者从水缸舀水。
假设我们需要把预期把水平面稳定在A平面，而实际水平面在B平面，
那么水平面差值Err=A-B，那这个时候我们需要往里面加水的量就是Kp*Err，
Kp就是我们的比例控制系数。

如果A>B，Err为正，就往水缸里面加水；如果A<B，Err为负，就从水缸里面舀水出来。
那么只要预期水平面和实际水平面有差值，我们都会通过水桶去加减水来调整系统。

这里也许有人会有疑问，如果这里把比例控制系数Kp直接设置成1，然后加水的量直接为Err=A-B不就可以了。
然而实际上很多系统是做不到这点的。比如温度控制系统，实际温度为10度，我要通过加热把温度提升到40度，
这里难道我们能一次性准确的给系统加30度？显然这是做不到的。那么比例控制的最终结果是Err的值趋向于0

I 积分控制
--------
积分控制部分的作用主要是用来消除静差。那么积分是怎样来消除静差的呢？
我们知道曲线的积分相当于曲线与x轴围出来的面积。比例控制只能尽量将Err调节到0，
但是会存在这样那样的误差。而微分的作用是将曲线的斜率控制到0则停止对其作用，
但斜率为0的时候Err并不一定为0。这个时候我们就需要积分来起作用了。

如下图，积分作用的目的是使红色部分的面积和蓝色部分的面积的和为0，
那么即使系统在比例控制和微分控制部分已经趋于稳定，只要Err不为0就会存在静差，
只要存在静差那么积分就会对系统产生影响，直到系统的Err值为0。
那么这样我们的PID控制在理论上就可以达到一个非常精确的控制效果。

![](/images/20160516160544222.png)

D 微分控制
--------
然后我们先看看微分控制。在我们的比例控制的作用下，Err是开始减小的
（假设一开始预期水平面A大于实际水平面B，也就是说Err是一个正值），
那么也就是说Err随时间是一条斜率小于0的曲线，那么在周期时间内，Err越大，
微分的绝对值越大，那么也就对Err的减小速度是起到抑制的作用的，
直到最后斜率为0微分才会停止作用。
那么随着微分的影响，Err曲线的斜率最终是趋向于0的，如下图：

![](/images/20160516111957278.png)




```c
unsigned int PIDCalc( struct PID *pp, unsigned int NextPoint )
{
	unsigned int dError,Error;
	Error = pp->SetPoint - NextPoint;          // 偏差
	pp->SumError += Error;                     // 积分
	dError = pp->LastError - pp->PrevError;    // 当前微分
	pp->PrevError = pp->LastError;
	pp->LastError = Error;
	return (pp->Proportion * Error             // 比例项
			+ pp->Integral * pp->SumError              // 积分项
			+ pp->Derivative * dError);                // 微分项
}
```
